"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getRoutes;
exports.normalizeAllRoutes = normalizeAllRoutes;
exports.normalizeRoute = normalizeRoute;
exports.rebuildRoutes = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _utils = require("../utils");

var _plugins = _interopRequireDefault(require("./plugins"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var rebuildRoutes = function rebuildRoutes() {
  rebuildRoutes.current();
};

exports.rebuildRoutes = rebuildRoutes;

rebuildRoutes.current = function () {
  throw new Error('Routes cannot be rebuilt yet!');
};

function getRoutes(_x) {
  return _getRoutes.apply(this, arguments);
} // We recursively loop through the routes and their children and
// return an array of normalised routes.
// Original routes array [{ path: 'path', children: { path: 'to' } }]
// These can be returned as flat routes eg. [{ path: 'path' }, { path: 'path/to' }]
// Or they can be returned nested routes eg. [{ path: 'path', children: { path: 'path/to' } }]


function _getRoutes() {
  _getRoutes = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(state) {
    var callback,
        _args2 = arguments;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            callback = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function (d) {
              return d;
            };
            rebuildRoutes.current =
            /*#__PURE__*/
            (0, _asyncToGenerator2["default"])(
            /*#__PURE__*/
            _regenerator["default"].mark(function _callee() {
              var _state, silent, incremental, pluginRoutes, userRoutes, routes, _normalizeAllRoutes, allNormalizedRoutes, hasIndex, has404;

              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _state = state, silent = _state.silent, incremental = _state.incremental;
                      if (!silent) console.log('Building Routes...');
                      if (!silent) (0, _utils.time)(_chalk["default"].green("[\u2713] Routes Built"));
                      _context.next = 5;
                      return _plugins["default"].beforePrepareRoutes(state);

                    case 5:
                      state = _context.sent;
                      _context.next = 8;
                      return _plugins["default"].getRoutes([], state);

                    case 8:
                      pluginRoutes = _context.sent;
                      _context.next = 11;
                      return state.config.getRoutes(state);

                    case 11:
                      userRoutes = _context.sent;
                      routes = [].concat((0, _toConsumableArray2["default"])(pluginRoutes), (0, _toConsumableArray2["default"])(userRoutes)); // Flatten and normalize all of the routes

                      _normalizeAllRoutes = normalizeAllRoutes(routes, state), allNormalizedRoutes = _normalizeAllRoutes.routes, hasIndex = _normalizeAllRoutes.hasIndex, has404 = _normalizeAllRoutes.has404; // If no Index page was found, throw an error. This is required

                      if (!(!hasIndex && !incremental)) {
                        _context.next = 17;
                        break;
                      }

                      console.error('No index found!');
                      throw new Error('Could not find a route for the "index" page of your site! This is ' + 'required. Please create a page or specify a route and template ' + 'for this page.');

                    case 17:
                      console.log({
                        has404: has404
                      }); // If no 404 page was found, add one. This is required.

                      if (!has404 && !incremental) {
                        console.warn('Creating default 404 because none was found...');
                        allNormalizedRoutes.unshift({
                          path: '404',
                          template: _path["default"].resolve(__dirname, _path["default"].join('..', 'browser', 'components', 'Default404'))
                        });
                      }

                      if (!silent) (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Routes Built"));
                      state = _objectSpread({}, state, {
                        routes: allNormalizedRoutes
                      });
                      _context.t0 = callback;
                      _context.next = 24;
                      return _plugins["default"].afterPrepareRoutes(state);

                    case 24:
                      _context.t1 = _context.sent;
                      return _context.abrupt("return", (0, _context.t0)(_context.t1));

                    case 26:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));
            return _context2.abrupt("return", rebuildRoutes.current());

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getRoutes.apply(this, arguments);
}

function normalizeAllRoutes(routes, state) {
  var routesByPath = {};
  var hasIndex;
  var has404; // This hook is set up beore the loop, since it could have expensive
  // overhead diving into plugins every time

  var pluginNormalizeRoute = _plugins["default"].normalizeRoute(state);

  var recurseRoute = function recurseRoute(route, parent) {
    // Normalize the route
    var normalizedRoute = normalizeRoute(route, parent, pluginNormalizeRoute); // we check an array of paths to see
    // if route path already existings

    var existingRoute = routesByPath[normalizedRoute.path]; // If the route has children, we do a depth-first recurse

    if (normalizedRoute.children) {
      normalizedRoute.children.forEach(function (childRoute) {
        return recurseRoute(childRoute, normalizedRoute);
      });
    } // If the route exists


    if (existingRoute) {
      // If it is meant to replace any routes before it
      if (!normalizedRoute.replace) {
        // If not replacing, we need to merge the two
        // routes together
        Object.assign(existingRoute, normalizedRoute); // Then make sure we're pointing to the exising route

        normalizedRoute = existingRoute;
      }
    }

    delete normalizedRoute.children; // Register the route by path

    routesByPath[normalizedRoute.path] = normalizedRoute; // Keep track of index and 404 routes existence

    if (normalizedRoute.path === '/') {
      hasIndex = true;
    }

    if (normalizedRoute.path === '404') {
      has404 = true;
    }

    if (normalizedRoute.path.indexOf('\\') !== -1) {
      throw new Error('Plugins must return a normalized path for the `path` key of a route,' + ' which is a path with / and not \\.');
    }
  };

  routes.forEach(function (route) {
    return recurseRoute(route);
  });
  var normalizedRoutes = Object.values(routesByPath);
  return {
    routes: normalizedRoutes,
    hasIndex: hasIndex,
    has404: has404
  };
}

function normalizeRoute(route) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var pluginNormalizeRoute = arguments.length > 2 ? arguments[2] : undefined;
  var _parent$path = parent.path,
      parentPath = _parent$path === void 0 ? '/' : _parent$path;

  if (!route.path) {
    throw new Error("No path defined for route: ".concat(JSON.stringify(route)));
  }

  var routePath = (0, _utils.pathJoin)(parentPath, route.path);

  if (typeof route.noIndex !== 'undefined') {
    console.warn("Warning: Route ".concat(route.path, " is using 'noIndex'. Did you mean 'noindex'?"));
  }

  route.path = (0, _utils.getRoutePath)(routePath);
  route.parent = parent;
  route = pluginNormalizeRoute(route);
  delete route.parent;
  return route;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvZ2V0Um91dGVzLmpzIl0sIm5hbWVzIjpbInJlYnVpbGRSb3V0ZXMiLCJjdXJyZW50IiwiRXJyb3IiLCJnZXRSb3V0ZXMiLCJzdGF0ZSIsImNhbGxiYWNrIiwiZCIsInNpbGVudCIsImluY3JlbWVudGFsIiwiY29uc29sZSIsImxvZyIsImNoYWxrIiwiZ3JlZW4iLCJwbHVnaW5zIiwiYmVmb3JlUHJlcGFyZVJvdXRlcyIsInBsdWdpblJvdXRlcyIsImNvbmZpZyIsInVzZXJSb3V0ZXMiLCJyb3V0ZXMiLCJub3JtYWxpemVBbGxSb3V0ZXMiLCJhbGxOb3JtYWxpemVkUm91dGVzIiwiaGFzSW5kZXgiLCJoYXM0MDQiLCJlcnJvciIsIndhcm4iLCJ1bnNoaWZ0IiwicGF0aCIsInRlbXBsYXRlIiwicmVzb2x2ZSIsIl9fZGlybmFtZSIsImpvaW4iLCJhZnRlclByZXBhcmVSb3V0ZXMiLCJyb3V0ZXNCeVBhdGgiLCJwbHVnaW5Ob3JtYWxpemVSb3V0ZSIsIm5vcm1hbGl6ZVJvdXRlIiwicmVjdXJzZVJvdXRlIiwicm91dGUiLCJwYXJlbnQiLCJub3JtYWxpemVkUm91dGUiLCJleGlzdGluZ1JvdXRlIiwiY2hpbGRyZW4iLCJmb3JFYWNoIiwiY2hpbGRSb3V0ZSIsInJlcGxhY2UiLCJPYmplY3QiLCJhc3NpZ24iLCJpbmRleE9mIiwibm9ybWFsaXplZFJvdXRlcyIsInZhbHVlcyIsInBhcmVudFBhdGgiLCJKU09OIiwic3RyaW5naWZ5Iiwicm91dGVQYXRoIiwibm9JbmRleCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7O0FBRU8sSUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFNO0FBQ2pDQSxFQUFBQSxhQUFhLENBQUNDLE9BQWQ7QUFDRCxDQUZNOzs7O0FBSVBELGFBQWEsQ0FBQ0MsT0FBZCxHQUF3QixZQUFNO0FBQzVCLFFBQU0sSUFBSUMsS0FBSixDQUFV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LENBQUNlLElBQVIsMEJBQ29CWSxLQUFLLENBQUNWLElBRDFCO0FBR0Q7O0FBRURVLEVBQUFBLEtBQUssQ0FBQ1YsSUFBTixHQUFhLHlCQUFhMEIsU0FBYixDQUFiO0FBRUFoQixFQUFBQSxLQUFLLENBQUNDLE1BQU4sR0FBZUEsTUFBZjtBQUNBRCxFQUFBQSxLQUFLLEdBQUdILG9CQUFvQixDQUFDRyxLQUFELENBQTVCO0FBQ0EsU0FBT0EsS0FBSyxDQUFDQyxNQUFiO0FBRUEsU0FBT0QsS0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcclxuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJ1xyXG4vL1xyXG5pbXBvcnQgeyBwYXRoSm9pbiwgZ2V0Um91dGVQYXRoLCB0aW1lLCB0aW1lRW5kIH0gZnJvbSAnLi4vdXRpbHMnXHJcbmltcG9ydCBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucydcclxuXHJcbmV4cG9ydCBjb25zdCByZWJ1aWxkUm91dGVzID0gKCkgPT4ge1xyXG4gIHJlYnVpbGRSb3V0ZXMuY3VycmVudCgpXHJcbn1cclxuXHJcbnJlYnVpbGRSb3V0ZXMuY3VycmVudCA9ICgpID0+IHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlcyBjYW5ub3QgYmUgcmVidWlsdCB5ZXQhJylcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ2V0Um91dGVzKHN0YXRlLCBjYWxsYmFjayA9IGQgPT4gZCkge1xyXG4gIHJlYnVpbGRSb3V0ZXMuY3VycmVudCA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHsgc2lsZW50LCBpbmNyZW1lbnRhbCB9ID0gc3RhdGVcclxuXHJcbiAgICBpZiAoIXNpbGVudCkgY29uc29sZS5sb2coJ0J1aWxkaW5nIFJvdXRlcy4uLicpXHJcbiAgICBpZiAoIXNpbGVudCkgdGltZShjaGFsay5ncmVlbignW1xcdTI3MTNdIFJvdXRlcyBCdWlsdCcpKVxyXG5cclxuICAgIHN0YXRlID0gYXdhaXQgcGx1Z2lucy5iZWZvcmVQcmVwYXJlUm91dGVzKHN0YXRlKVxyXG5cclxuICAgIGNvbnN0IHBsdWdpblJvdXRlcyA9IGF3YWl0IHBsdWdpbnMuZ2V0Um91dGVzKFtdLCBzdGF0ZSlcclxuICAgIGNvbnN0IHVzZXJSb3V0ZXMgPSBhd2FpdCBzdGF0ZS5jb25maWcuZ2V0Um91dGVzKHN0YXRlKVxyXG5cclxuICAgIGNvbnN0IHJvdXRlcyA9IFsuLi5wbHVnaW5Sb3V0ZXMsIC4uLnVzZXJSb3V0ZXNdXHJcblxyXG4gICAgLy8gRmxhdHRlbiBhbmQgbm9ybWFsaXplIGFsbCBvZiB0aGUgcm91dGVzXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJvdXRlczogYWxsTm9ybWFsaXplZFJvdXRlcyxcclxuICAgICAgaGFzSW5kZXgsXHJcbiAgICAgIGhhczQwNCxcclxuICAgIH0gPSBub3JtYWxpemVBbGxSb3V0ZXMocm91dGVzLCBzdGF0ZSlcclxuXHJcbiAgICAvLyBJZiBubyBJbmRleCBwYWdlIHdhcyBmb3VuZCwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgcmVxdWlyZWRcclxuICAgIGlmICghaGFzSW5kZXggJiYgIWluY3JlbWVudGFsKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGluZGV4IGZvdW5kIScpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnQ291bGQgbm90IGZpbmQgYSByb3V0ZSBmb3IgdGhlIFwiaW5kZXhcIiBwYWdlIG9mIHlvdXIgc2l0ZSEgVGhpcyBpcyAnICtcclxuICAgICAgICAgICdyZXF1aXJlZC4gUGxlYXNlIGNyZWF0ZSBhIHBhZ2Ugb3Igc3BlY2lmeSBhIHJvdXRlIGFuZCB0ZW1wbGF0ZSAnICtcclxuICAgICAgICAgICdmb3IgdGhpcyBwYWdlLidcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKHsgaGFzNDA0IH0pXHJcblxyXG4gICAgLy8gSWYgbm8gNDA0IHBhZ2Ugd2FzIGZvdW5kLCBhZGQgb25lLiBUaGlzIGlzIHJlcXVpcmVkLlxyXG4gICAgaWYgKCFoYXM0MDQgJiYgIWluY3JlbWVudGFsKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignQ3JlYXRpbmcgZGVmYXVsdCA0MDQgYmVjYXVzZSBub25lIHdhcyBmb3VuZC4uLicpXHJcblxyXG4gICAgICBhbGxOb3JtYWxpemVkUm91dGVzLnVuc2hpZnQoe1xyXG4gICAgICAgIHBhdGg6ICc0MDQnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBwYXRoLnJlc29sdmUoXHJcbiAgICAgICAgICBfX2Rpcm5hbWUsXHJcbiAgICAgICAgICBwYXRoLmpvaW4oJy4uJywgJ2Jyb3dzZXInLCAnY29tcG9uZW50cycsICdEZWZhdWx0NDA0JylcclxuICAgICAgICApLFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2lsZW50KSB0aW1lRW5kKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gUm91dGVzIEJ1aWx0JykpXHJcblxyXG4gICAgc3RhdGUgPSB7XHJcbiAgICAgIC4uLnN0YXRlLFxyXG4gICAgICByb3V0ZXM6IGFsbE5vcm1hbGl6ZWRSb3V0ZXMsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbGxiYWNrKGF3YWl0IHBsdWdpbnMuYWZ0ZXJQcmVwYXJlUm91dGVzKHN0YXRlKSlcclxuICB9XHJcblxyXG4gIHJldHVybiByZWJ1aWxkUm91dGVzLmN1cnJlbnQoKVxyXG59XHJcblxyXG4vLyBXZSByZWN1cnNpdmVseSBsb29wIHRocm91Z2ggdGhlIHJvdXRlcyBhbmQgdGhlaXIgY2hpbGRyZW4gYW5kXHJcbi8vIHJldHVybiBhbiBhcnJheSBvZiBub3JtYWxpc2VkIHJvdXRlcy5cclxuLy8gT3JpZ2luYWwgcm91dGVzIGFycmF5IFt7IHBhdGg6ICdwYXRoJywgY2hpbGRyZW46IHsgcGF0aDogJ3RvJyB9IH1dXHJcbi8vIFRoZXNlIGNhbiBiZSByZXR1cm5lZCBhcyBmbGF0IHJvdXRlcyBlZy4gW3sgcGF0aDogJ3BhdGgnIH0sIHsgcGF0aDogJ3BhdGgvdG8nIH1dXHJcbi8vIE9yIHRoZXkgY2FuIGJlIHJldHVybmVkIG5lc3RlZCByb3V0ZXMgZWcuIFt7IHBhdGg6ICdwYXRoJywgY2hpbGRyZW46IHsgcGF0aDogJ3BhdGgvdG8nIH0gfV1cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFsbFJvdXRlcyhyb3V0ZXMsIHN0YXRlKSB7XHJcbiAgY29uc3Qgcm91dGVzQnlQYXRoID0ge31cclxuICBsZXQgaGFzSW5kZXhcclxuICBsZXQgaGFzNDA0XHJcblxyXG4gIC8vIFRoaXMgaG9vayBpcyBzZXQgdXAgYmVvcmUgdGhlIGxvb3AsIHNpbmNlIGl0IGNvdWxkIGhhdmUgZXhwZW5zaXZlXHJcbiAgLy8gb3ZlcmhlYWQgZGl2aW5nIGludG8gcGx1Z2lucyBldmVyeSB0aW1lXHJcbiAgY29uc3QgcGx1Z2luTm9ybWFsaXplUm91dGUgPSBwbHVnaW5zLm5vcm1hbGl6ZVJvdXRlKHN0YXRlKVxyXG5cclxuICBjb25zdCByZWN1cnNlUm91dGUgPSAocm91dGUsIHBhcmVudCkgPT4ge1xyXG4gICAgLy8gTm9ybWFsaXplIHRoZSByb3V0ZVxyXG4gICAgbGV0IG5vcm1hbGl6ZWRSb3V0ZSA9IG5vcm1hbGl6ZVJvdXRlKHJvdXRlLCBwYXJlbnQsIHBsdWdpbk5vcm1hbGl6ZVJvdXRlKVxyXG5cclxuICAgIC8vIHdlIGNoZWNrIGFuIGFycmF5IG9mIHBhdGhzIHRvIHNlZVxyXG4gICAgLy8gaWYgcm91dGUgcGF0aCBhbHJlYWR5IGV4aXN0aW5nc1xyXG4gICAgY29uc3QgZXhpc3RpbmdSb3V0ZSA9IHJvdXRlc0J5UGF0aFtub3JtYWxpemVkUm91dGUucGF0aF1cclxuXHJcbiAgICAvLyBJZiB0aGUgcm91dGUgaGFzIGNoaWxkcmVuLCB3ZSBkbyBhIGRlcHRoLWZpcnN0IHJlY3Vyc2VcclxuICAgIGlmIChub3JtYWxpemVkUm91dGUuY2hpbGRyZW4pIHtcclxuICAgICAgbm9ybWFsaXplZFJvdXRlLmNoaWxkcmVuLmZvckVhY2goY2hpbGRSb3V0ZSA9PlxyXG4gICAgICAgIHJlY3Vyc2VSb3V0ZShjaGlsZFJvdXRlLCBub3JtYWxpemVkUm91dGUpXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgcm91dGUgZXhpc3RzXHJcbiAgICBpZiAoZXhpc3RpbmdSb3V0ZSkge1xyXG4gICAgICAvLyBJZiBpdCBpcyBtZWFudCB0byByZXBsYWNlIGFueSByb3V0ZXMgYmVmb3JlIGl0XHJcbiAgICAgIGlmICghbm9ybWFsaXplZFJvdXRlLnJlcGxhY2UpIHtcclxuICAgICAgICAvLyBJZiBub3QgcmVwbGFjaW5nLCB3ZSBuZWVkIHRvIG1lcmdlIHRoZSB0d29cclxuICAgICAgICAvLyByb3V0ZXMgdG9nZXRoZXJcclxuICAgICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nUm91dGUsIG5vcm1hbGl6ZWRSb3V0ZSlcclxuICAgICAgICAvLyBUaGVuIG1ha2Ugc3VyZSB3ZSdyZSBwb2ludGluZyB0byB0aGUgZXhpc2luZyByb3V0ZVxyXG4gICAgICAgIG5vcm1hbGl6ZWRSb3V0ZSA9IGV4aXN0aW5nUm91dGVcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSBub3JtYWxpemVkUm91dGUuY2hpbGRyZW5cclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgcm91dGUgYnkgcGF0aFxyXG4gICAgcm91dGVzQnlQYXRoW25vcm1hbGl6ZWRSb3V0ZS5wYXRoXSA9IG5vcm1hbGl6ZWRSb3V0ZVxyXG5cclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgaW5kZXggYW5kIDQwNCByb3V0ZXMgZXhpc3RlbmNlXHJcbiAgICBpZiAobm9ybWFsaXplZFJvdXRlLnBhdGggPT09ICcvJykge1xyXG4gICAgICBoYXNJbmRleCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFJvdXRlLnBhdGggPT09ICc0MDQnKSB7XHJcbiAgICAgIGhhczQwNCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFJvdXRlLnBhdGguaW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ1BsdWdpbnMgbXVzdCByZXR1cm4gYSBub3JtYWxpemVkIHBhdGggZm9yIHRoZSBgcGF0aGAga2V5IG9mIGEgcm91dGUsJyArXHJcbiAgICAgICAgICAnIHdoaWNoIGlzIGEgcGF0aCB3aXRoIC8gYW5kIG5vdCBcXFxcLidcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcm91dGVzLmZvckVhY2gocm91dGUgPT4gcmVjdXJzZVJvdXRlKHJvdXRlKSlcclxuXHJcbiAgY29uc3Qgbm9ybWFsaXplZFJvdXRlcyA9IE9iamVjdC52YWx1ZXMocm91dGVzQnlQYXRoKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcm91dGVzOiBub3JtYWxpemVkUm91dGVzLFxyXG4gICAgaGFzSW5kZXgsXHJcbiAgICBoYXM0MDQsXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUm91dGUocm91dGUsIHBhcmVudCA9IHt9LCBwbHVnaW5Ob3JtYWxpemVSb3V0ZSkge1xyXG4gIGNvbnN0IHsgcGF0aDogcGFyZW50UGF0aCA9ICcvJyB9ID0gcGFyZW50XHJcblxyXG4gIGlmICghcm91dGUucGF0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBwYXRoIGRlZmluZWQgZm9yIHJvdXRlOiAke0pTT04uc3RyaW5naWZ5KHJvdXRlKX1gKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgcm91dGVQYXRoID0gcGF0aEpvaW4ocGFyZW50UGF0aCwgcm91dGUucGF0aClcclxuXHJcbiAgaWYgKHR5cGVvZiByb3V0ZS5ub0luZGV4ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICBgV2FybmluZzogUm91dGUgJHtyb3V0ZS5wYXRofSBpcyB1c2luZyAnbm9JbmRleCcuIERpZCB5b3UgbWVhbiAnbm9pbmRleCc/YFxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcm91dGUucGF0aCA9IGdldFJvdXRlUGF0aChyb3V0ZVBhdGgpXHJcblxyXG4gIHJvdXRlLnBhcmVudCA9IHBhcmVudFxyXG4gIHJvdXRlID0gcGx1Z2luTm9ybWFsaXplUm91dGUocm91dGUpXHJcbiAgZGVsZXRlIHJvdXRlLnBhcmVudFxyXG5cclxuICByZXR1cm4gcm91dGVcclxufVxyXG4iXX0=