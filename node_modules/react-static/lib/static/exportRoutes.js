"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _os = _interopRequireDefault(require("os"));

var _child_process = require("child_process");

var _chalk = _interopRequireDefault(require("chalk"));

var _utils = require("../utils");

var _fetchSiteData = _interopRequireDefault(require("./fetchSiteData"));

var _fetchRoutes = _interopRequireDefault(require("./fetchRoutes"));

var _plugins = _interopRequireDefault(require("./plugins"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var cores = Math.max(_os["default"].cpus().length, 1);

var _default =
/*#__PURE__*/
function () {
  var _exportRoutes = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(state) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _fetchSiteData["default"])(state);

          case 2:
            state = _context.sent;
            _context.next = 5;
            return (0, _fetchRoutes["default"])(state);

          case 5:
            state = _context.sent;
            _context.next = 8;
            return buildHTML(state);

          case 8:
            state = _context.sent;
            _context.next = 11;
            return _plugins["default"].afterExport(state);

          case 11:
            state = _context.sent;
            return _context.abrupt("return", state);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function exportRoutes(_x) {
    return _exportRoutes.apply(this, arguments);
  }

  return exportRoutes;
}();

exports["default"] = _default;

function buildHTML(_x2) {
  return _buildHTML.apply(this, arguments);
}

function _buildHTML() {
  _buildHTML = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(state) {
    var routes, _state$config, paths, maxThreads, threads, htmlProgress, exporters, i, exporterRoutes;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            routes = state.routes, _state$config = state.config, paths = _state$config.paths, maxThreads = _state$config.maxThreads;
            (0, _utils.time)(_chalk["default"].green("[\u2713] HTML Exported")); // in case of an absolute path for DIST we must tell node to load the modules
            // from our project root

            if (!paths.DIST.startsWith(paths.ROOT)) {
              process.env.NODE_PATH = paths.NODE_MODULES;

              require('module').Module._initPaths();
            } // Single threaded export


            if (!(maxThreads <= 1)) {
              _context2.next = 9;
              break;
            }

            console.log('Exporting HTML...');
            _context2.next = 7;
            return require('./exportRoutes.sync')["default"](state);

          case 7:
            _context2.next = 18;
            break;

          case 9:
            // Multi-threaded export
            threads = Math.min(cores, maxThreads);
            htmlProgress = (0, _utils.progress)(routes.length);
            console.log("Exporting HTML across ".concat(threads, " threads..."));
            exporters = [];

            for (i = 0; i < threads; i++) {
              exporters.push((0, _child_process.fork)(require.resolve('./exportRoutes.threaded'), [], {
                env: _objectSpread({}, process.env, {
                  REACT_STATIC_THREAD: 'true'
                }),
                stdio: 'inherit'
              }));
            }

            exporterRoutes = exporters.map(function () {
              return [];
            });
            routes.forEach(function (route, i) {
              exporterRoutes[i % exporterRoutes.length].push(route);
            });
            _context2.next = 18;
            return Promise.all(exporters.map(function (exporter, i) {
              var routes = exporterRoutes[i];
              return new Promise(function (resolve, reject) {
                exporter.send(_objectSpread({}, state, {
                  routes: routes
                }));
                exporter.on('message', function (_ref) {
                  var type = _ref.type,
                      payload = _ref.payload;

                  if (type === 'error') {
                    reject(payload);
                  }

                  if (type === 'log') {
                    var _console;

                    (_console = console).log.apply(_console, (0, _toConsumableArray2["default"])(payload));
                  }

                  if (type === 'tick') {
                    htmlProgress.tick();
                  }

                  if (type === 'done') {
                    resolve();
                  }
                });
              });
            }));

          case 18:
            (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] HTML Exported"));
            return _context2.abrupt("return", state);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _buildHTML.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvZXhwb3J0Um91dGVzLmpzIl0sIm5hbWVzIjpbImNvcmVzIiwiTWF0aCIsIm1heCIsIk9TIiwiY3B1cyIsImxlbmd0aCIsInN0YXRlIiwiYnVpbGRIVE1MIiwicGx1Z2lucyIsImFmdGVyRXhwb3J0IiwiZXhwb3J0Um91dGVzIiwicm91dGVzIiwiY29uZmlnIiwicGF0aHMiLCJtYXhUaHJlYWRzIiwiY2hhbGsiLCJncmVlbiIsIkRJU1QiLCJzdGFydHNXaXRoIiwiUk9PVCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1BBVEgiLCJOT0RFX01PRFVMRVMiLCJyZXF1aXJlIiwiTW9kdWxlIiwiX2luaXRQYXRocyIsImNvbnNvbGUiLCJsb2ciLCJ0aHJlYWRzIiwibWluIiwiaHRtbFByb2dyZXNzIiwiZXhwb3J0ZXJzIiwiaSIsInB1c2giLCJyZXNvbHZlIiwiUkVBQ1RfU1RBVElDX1RIUkVBRCIsInN0ZGlvIiwiZXhwb3J0ZXJSb3V0ZXMiLCJtYXAiLCJmb3JFYWNoIiwicm91dGUiLCJQcm9taXNlIiwiYWxsIiwiZXhwb3J0ZXIiLCJyZWplY3QiLCJzZW5kIiwib24iLCJ0eXBlIiwicGF5bG9hZCIsInRpY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLEtBQUssR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNDLGVBQUdDLElBQUgsR0FBVUMsTUFBbkIsRUFBMkIsQ0FBM0IsQ0FBZDs7Ozs7OzsrQkFFZ0IsaUJBQTRCQyxLQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFDQSwrQkFBY0EsS0FBZCxDQURBOztBQUFBO0FBQ2RBLFlBQUFBLEtBRGM7QUFBQTtBQUFBLG1CQUVBLDZCQUFZQSxLQUFaLENBRkE7O0FBQUE7QUFFZEEsWUFBQUEsS0FGYztBQUFBO0FBQUEsbUJBR0FDLFNBQVMsQ0FBQ0QsS0FB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TSxFQUFOQTtBQUZGO0FBSUFpQyxnQkFBQUEsUUFBUSxDQUFDRyxFQUFULENBQVksU0FBWixFQUF1QixnQkFBdUI7QUFBQSxzQkFBcEJDLElBQW9CLFFBQXBCQSxJQUFvQjtBQUFBLHNCQUFkQyxPQUFjLFFBQWRBLE9BQWM7O0FBQzVDLHNCQUFJRCxJQUFJLEtBQUssT0FBYixFQUFzQjtBQUNwQkgsb0JBQUFBLE1BQU0sQ0FBQ0ksT0FBRCxDQUFOO0FBQ0Q7O0FBQ0Qsc0JBQUlELElBQUksS0FBSyxLQUFiLEVBQW9CO0FBQUE7O0FBQ2xCLGdDQUFBckIsT0FBTyxFQUFDQyxHQUFSLHFEQUFlcUIsT0FBZjtBQUNEOztBQUNELHNCQUFJRCxJQUFJLEtBQUssTUFBYixFQUFxQjtBQUNuQmpCLG9CQUFBQSxZQUFZLENBQUNtQixJQUFiO0FBQ0Q7O0FBQ0Qsc0JBQUlGLElBQUksS0FBSyxNQUFiLEVBQXFCO0FBQ25CYixvQkFBQUEsT0FBTztBQUNSO0FBQ0YsaUJBYkQ7QUFjRCxlQW5CTSxDQUFQO0FBb0JELGFBdEJELENBREksQ0E3Q1Y7O0FBQUE7QUF3RUUsZ0NBQVFwQixrQkFBTUMsS0FBTixDQUFZLHdCQUFaLENBQVI7QUF4RUYsOENBMEVTVixLQTFFVDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9TIGZyb20gJ29zJ1xyXG5pbXBvcnQgeyBmb3JrIH0gZnJvbSAnY2hpbGRfcHJvY2VzcydcclxuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJ1xyXG5cclxuaW1wb3J0IHsgcHJvZ3Jlc3MsIHRpbWUsIHRpbWVFbmQgfSBmcm9tICcuLi91dGlscydcclxuaW1wb3J0IGZldGNoU2l0ZURhdGEgZnJvbSAnLi9mZXRjaFNpdGVEYXRhJ1xyXG5pbXBvcnQgZmV0Y2hSb3V0ZXMgZnJvbSAnLi9mZXRjaFJvdXRlcydcclxuaW1wb3J0IHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zJ1xyXG5cclxuY29uc3QgY29yZXMgPSBNYXRoLm1heChPUy5jcHVzKCkubGVuZ3RoLCAxKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgKGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFJvdXRlcyhzdGF0ZSkge1xyXG4gIHN0YXRlID0gYXdhaXQgZmV0Y2hTaXRlRGF0YShzdGF0ZSlcclxuICBzdGF0ZSA9IGF3YWl0IGZldGNoUm91dGVzKHN0YXRlKVxyXG4gIHN0YXRlID0gYXdhaXQgYnVpbGRIVE1MKHN0YXRlKVxyXG4gIHN0YXRlID0gYXdhaXQgcGx1Z2lucy5hZnRlckV4cG9ydChzdGF0ZSlcclxuICByZXR1cm4gc3RhdGVcclxufSlcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkSFRNTChzdGF0ZSkge1xyXG4gIGNvbnN0IHtcclxuICAgIHJvdXRlcyxcclxuICAgIGNvbmZpZzogeyBwYXRocywgbWF4VGhyZWFkcyB9LFxyXG4gIH0gPSBzdGF0ZVxyXG5cclxuICB0aW1lKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gSFRNTCBFeHBvcnRlZCcpKVxyXG5cclxuICAvLyBpbiBjYXNlIG9mIGFuIGFic29sdXRlIHBhdGggZm9yIERJU1Qgd2UgbXVzdCB0ZWxsIG5vZGUgdG8gbG9hZCB0aGUgbW9kdWxlc1xyXG4gIC8vIGZyb20gb3VyIHByb2plY3Qgcm9vdFxyXG4gIGlmICghcGF0aHMuRElTVC5zdGFydHNXaXRoKHBhdGhzLlJPT1QpKSB7XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX1BBVEggPSBwYXRocy5OT0RFX01PRFVMRVNcclxuICAgIHJlcXVpcmUoJ21vZHVsZScpLk1vZHVsZS5faW5pdFBhdGhzKClcclxuICB9XHJcblxyXG4gIC8vIFNpbmdsZSB0aHJlYWRlZCBleHBvcnRcclxuICBpZiAobWF4VGhyZWFkcyA8PSAxKSB7XHJcbiAgICBjb25zb2xlLmxvZygnRXhwb3J0aW5nIEhUTUwuLi4nKVxyXG4gICAgYXdhaXQgcmVxdWlyZSgnLi9leHBvcnRSb3V0ZXMuc3luYycpLmRlZmF1bHQoc3RhdGUpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIE11bHRpLXRocmVhZGVkIGV4cG9ydFxyXG4gICAgY29uc3QgdGhyZWFkcyA9IE1hdGgubWluKGNvcmVzLCBtYXhUaHJlYWRzKVxyXG4gICAgY29uc3QgaHRtbFByb2dyZXNzID0gcHJvZ3Jlc3Mocm91dGVzLmxlbmd0aClcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRXhwb3J0aW5nIEhUTUwgYWNyb3NzICR7dGhyZWFkc30gdGhyZWFkcy4uLmApXHJcblxyXG4gICAgY29uc3QgZXhwb3J0ZXJzID0gW11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhyZWFkczsgaSsrKSB7XHJcbiAgICAgIGV4cG9ydGVycy5wdXNoKFxyXG4gICAgICAgIGZvcmsocmVxdWlyZS5yZXNvbHZlKCcuL2V4cG9ydFJvdXRlcy50aHJlYWRlZCcpLCBbXSwge1xyXG4gICAgICAgICAgZW52OiB7XHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxyXG4gICAgICAgICAgICBSRUFDVF9TVEFUSUNfVEhSRUFEOiAndHJ1ZScsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3RkaW86ICdpbmhlcml0JyxcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhwb3J0ZXJSb3V0ZXMgPSBleHBvcnRlcnMubWFwKCgpID0+IFtdKVxyXG5cclxuICAgIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaSkgPT4ge1xyXG4gICAgICBleHBvcnRlclJvdXRlc1tpICUgZXhwb3J0ZXJSb3V0ZXMubGVuZ3RoXS5wdXNoKHJvdXRlKVxyXG4gICAgfSlcclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgZXhwb3J0ZXJzLm1hcCgoZXhwb3J0ZXIsIGkpID0+IHtcclxuICAgICAgICBjb25zdCByb3V0ZXMgPSBleHBvcnRlclJvdXRlc1tpXVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICBleHBvcnRlci5zZW5kKHtcclxuICAgICAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgICAgIHJvdXRlcyxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICBleHBvcnRlci5vbignbWVzc2FnZScsICh7IHR5cGUsIHBheWxvYWQgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgIHJlamVjdChwYXlsb2FkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbG9nJykge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLnBheWxvYWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0aWNrJykge1xyXG4gICAgICAgICAgICAgIGh0bWxQcm9ncmVzcy50aWNrKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RvbmUnKSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIClcclxuICB9XHJcblxyXG4gIHRpbWVFbmQoY2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBIVE1MIEV4cG9ydGVkJykpXHJcblxyXG4gIHJldHVybiBzdGF0ZVxyXG59XHJcbiJdfQ==