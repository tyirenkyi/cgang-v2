"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathJoin = pathJoin;
exports.getRoutePath = getRoutePath;
exports.unwrapArray = unwrapArray;
exports.isObject = isObject;
exports.deprecate = deprecate;
exports.removal = removal;
exports.isAbsoluteUrl = isAbsoluteUrl;
exports.makePathAbsolute = makePathAbsolute;
exports.reduceHooks = reduceHooks;
exports.mapHooks = mapHooks;
exports.getHooks = getHooks;
exports.getFullRouteData = getFullRouteData;
Object.defineProperty(exports, "poolAll", {
  enumerable: true,
  get: function get() {
    return _swimmer.poolAll;
  }
});
Object.defineProperty(exports, "createPool", {
  enumerable: true,
  get: function get() {
    return _swimmer.createPool;
  }
});
exports.cleanSlashes = exports.trimDoubleSlashes = exports.trimTrailingSlashes = exports.trimLeadingSlashes = exports.cutPathToRoot = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _swimmer = require("swimmer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REGEX_TO_CUT_TO_ROOT = /(\..+?)\/.*/g;
var REGEX_TO_REMOVE_LEADING_SLASH = /^\/{1,}/g;
var REGEX_TO_REMOVE_TRAILING_SLASH = /\/{1,}$/g;
var REGEX_TO_REMOVE_DOUBLE_SLASH = /\/{2,}/g;

var cutPathToRoot = function cutPathToRoot() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return string.replace(REGEX_TO_CUT_TO_ROOT, '$1');
};

exports.cutPathToRoot = cutPathToRoot;

var trimLeadingSlashes = function trimLeadingSlashes() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return string.replace(REGEX_TO_REMOVE_LEADING_SLASH, '');
};

exports.trimLeadingSlashes = trimLeadingSlashes;

var trimTrailingSlashes = function trimTrailingSlashes() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return string.replace(REGEX_TO_REMOVE_TRAILING_SLASH, '');
};

exports.trimTrailingSlashes = trimTrailingSlashes;

var trimDoubleSlashes = function trimDoubleSlashes() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (isAbsoluteUrl(string)) {
    var _string$split = string.split('://'),
        _string$split2 = (0, _slicedToArray2["default"])(_string$split, 2),
        _string$split2$ = _string$split2[0],
        scheme = _string$split2$ === void 0 ? '' : _string$split2$,
        _string$split2$2 = _string$split2[1],
        path = _string$split2$2 === void 0 ? '' : _string$split2$2;

    return [scheme, path.replace(REGEX_TO_REMOVE_DOUBLE_SLASH, '/')].join('://');
  }

  return string.replace(REGEX_TO_REMOVE_DOUBLE_SLASH, '/');
};

exports.trimDoubleSlashes = trimDoubleSlashes;

var cleanSlashes = function cleanSlashes(string) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!string) return '';

  var _options$leading = options.leading,
      leading = _options$leading === void 0 ? true : _options$leading,
      _options$trailing = options.trailing,
      trailing = _options$trailing === void 0 ? true : _options$trailing,
      _options$double = options["double"],
      _double = _options$double === void 0 ? true : _options$double;

  var cleanedString = string;

  if (leading) {
    cleanedString = trimLeadingSlashes(cleanedString);
  }

  if (trailing) {
    cleanedString = trimTrailingSlashes(cleanedString);
  }

  if (_double) {
    cleanedString = trimDoubleSlashes(cleanedString);
  }

  return cleanedString;
};

exports.cleanSlashes = cleanSlashes;

function pathJoin() {
  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }

  var newPath = paths.map(cleanSlashes).join('/');

  if (!newPath || newPath === '/') {
    return '/';
  }

  newPath = cleanSlashes(newPath);

  if (newPath.includes('?')) {
    newPath = newPath.substring(0, newPath.indexOf('?'));
  }

  return newPath;
} // This function is for extracting a routePath from a path or string
// RoutePaths do not have query params, basePaths, and should
// resemble the same string as passed in the static.config.js routes


function getRoutePath(routePath) {
  // Detect falsey paths and the root path
  if (!routePath || routePath === '/' || routePath === process.env.REACT_STATIC_BASE_PATH) {
    return '/';
  } // Remove origin, hashes, and query params


  if (typeof document !== 'undefined') {
    routePath = routePath.replace(window.location.origin, '');
    routePath = routePath.replace(/#.*/, '');
    routePath = routePath.replace(/\?.*/, '');
  } // Be sure to remove the base path


  if (process.env.REACT_STATIC_BASE_PATH) {
    routePath = routePath.replace(new RegExp("^\\/?".concat(process.env.REACT_STATIC_BASE_PATH, "\\/")), '');
  }

  routePath = routePath || '/';
  return pathJoin(routePath);
}

function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? arg[0] : arg;

  if (!arg && defaultValue) {
    return defaultValue;
  }

  return arg;
}

function isObject(a) {
  return !Array.isArray(a) && (0, _typeof2["default"])(a) === 'object' && a !== null;
}

function deprecate(from, to) {
  console.warn("React-Static deprecation notice: ".concat(from, " will be deprecated in favor of ").concat(to, " in the next major release."));
}

function removal(from) {
  console.warn("React-Static removal notice: ".concat(from, " is no longer supported in this version of React-Static. Please refer to the CHANGELOG for details."));
}

function isAbsoluteUrl(url) {
  if (typeof url !== 'string') {
    return false;
  }

  return /^[a-z][a-z0-9+.-]*:/.test(url);
}

function makePathAbsolute(path) {
  if (typeof path !== 'string') {
    return '/';
  }

  if (isAbsoluteUrl(path)) {
    return path;
  }

  return "/".concat(trimLeadingSlashes(path));
}

function reduceHooks(hooks) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      sync = _ref.sync;

  // These returns a runner that takes a value (and options) and
  // reduces the value through each hook, returning the
  // final value
  // compare is a function which is used to compare
  // the prev and next value and decide which to use.
  // By default, if undefined is returned from a reducer, the prev value
  // is retained
  // If synchronous, things are simple
  if (sync) {
    return function (value, options) {
      return hooks.reduce(function (prev, hook) {
        var next = hook(prev, options);

        if (next instanceof Promise) {
          throw new Error('Expected hook to return a value, but received promise instead. A plugin is attempting to use a sync plugin with an async function!');
        }

        return typeof next !== 'undefined' ? next : prev;
      }, value);
    };
  } // We create a map of hook handlers that point to the next hook
  // in line and reduce the value throughout (or return it if it's done)


  return function (startValue, options) {
    var hookList = hooks.map(function (hook, index) {
      return (
        /*#__PURE__*/
        function () {
          var _ref2 = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee(lastValue) {
            var nextValue;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return hook(lastValue, options);

                  case 2:
                    nextValue = _context.sent;
                    nextValue = typeof nextValue !== 'undefined' ? nextValue : lastValue;

                    if (!hookList[index + 1]) {
                      _context.next = 6;
                      break;
                    }

                    return _context.abrupt("return", hookList[index + 1](nextValue));

                  case 6:
                    return _context.abrupt("return", nextValue);

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x) {
            return _ref2.apply(this, arguments);
          };
        }()
      );
    });
    return hookList.length ? hookList[0](startValue) : startValue;
  };
}

function mapHooks(hooks) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      sync = _ref3.sync;

  // Returns a function that takes state and returns
  // a flat array of values mapped from each hook
  if (sync) {
    return function (state) {
      var results = hooks.map(function (hook) {
        return hook(state);
      });
      return results.filter(function (d) {
        return typeof d !== 'undefined';
      });
    };
  }

  return function (state) {
    var results = [];
    var hookList = hooks.map(function (hook, index) {
      return (
        /*#__PURE__*/
        (0, _asyncToGenerator2["default"])(
        /*#__PURE__*/
        _regenerator["default"].mark(function _callee2() {
          return _regenerator["default"].wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return hook(state);

                case 2:
                  results[index] = _context2.sent;

                  if (!hookList[index + 1]) {
                    _context2.next = 5;
                    break;
                  }

                  return _context2.abrupt("return", hookList[index + 1]());

                case 5:
                  return _context2.abrupt("return", results.filter(function (d) {
                    return typeof d !== 'undefined';
                  }));

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))
      );
    });
    return hookList.length ? hookList[0]() : [];
  };
}

function getHooks(plugins, hook) {
  if (!hook) {
    throw new Error('A hook ID is required!');
  } // The flat hooks


  var hooks = []; // Adds a plugin hook to the hook list

  var addToHooks = function addToHooks(plugin) {
    // Add the hook
    hooks.push(plugin.hooks[hook]); // Recurse into sub plugins if needs be

    if (plugin.plugins) {
      plugin.plugins.forEach(addToHooks);
    }
  }; // Start with the config plugins


  plugins.forEach(addToHooks); // Filter out falsey entries

  return hooks.filter(Boolean);
}

function getFullRouteData(routeInfo) {
  return _objectSpread({}, routeInfo.sharedData ? routeInfo.sharedData : {}, {}, routeInfo.data);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9icm93c2VyL3V0aWxzL2luZGV4LmpzIl0sIm5hbWVzIjpbIlJFR0VYX1RPX0NVVF9UT19ST09UIiwiUkVHRVhfVE9fUkVNT1ZFX0xFQURJTkdfU0xBU0giLCJSRUdFWF9UT19SRU1PVkVfVFJBSUxJTkdfU0xBU0giLCJSRUdFWF9UT19SRU1PVkVfRE9VQkxFX1NMQVNIIiwiY3V0UGF0aFRvUm9vdCIsInN0cmluZyIsInJlcGxhY2UiLCJ0cmltTGVhZGluZ1NsYXNoZXMiLCJ0cmltVHJhaWxpbmdTbGFzaGVzIiwidHJpbURvdWJsZVNsYXNoZXMiLCJpc0Fic29sdXRlVXJsIiwic3BsaXQiLCJzY2hlbWUiLCJwYXRoIiwiam9pbiIsImNsZWFuU2xhc2hlcyIsIm9wdGlvbnMiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJkb3VibGUiLCJjbGVhbmVkU3RyaW5nIiwicGF0aEpvaW4iLCJwYXRocyIsIm5ld1BhdGgiLCJtYXAiLCJpbmNsdWRlcyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJnZXRSb3V0ZVBhdGgiLCJyb3V0ZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiUkVBQ1RfU1RBVElDX0JBU0VfUEFUSCIsImRvY3VtZW50Iiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJSZWdFeHAiLCJ1bndyYXBBcnJheSIsImFyZyIsImRlZmF1bHRWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImlzT2JqZWN0IiwiYSIsImRlcHJlY2F0ZSIsImZyb20iLCJ0byIsImNvbnNvbGUiLCJ3YXJuIiwicmVtb3ZhbCIsInVybCIsInRlc3QiLCJtYWtlUGF0aEFic29sdXRlIiwicmVkdWNlSG9va3MiLCJob29rcyIsInN5bmMiLCJ2YWx1ZSIsInJlZHVjZSIsInByZXYiLCJob29rIiwibmV4dCIsIlByb21pc2UiLCJFcnJvciIsInN0YXJ0VmFsdWUiLCJob29rTGlzdCIsImluZGV4IiwibGFzdFZhbHVlIiwibmV4dFZhbHVlIiwibGVuZ3RoIiwibWFwSG9va3MiLCJzdGF0ZSIsInJlc3VsdHMiLCJmaWx0ZXIiLCJkIiwiZ2V0SG9va3MiLCJwbHVnaW5zIiwiYWRkVG9Ib29rcyIsInBsdWdpbiIsInB1c2giLCJmb3JFYWNoIiwiQm9vbGVhbiIsImdldEZ1bGxSb3V0ZURhdGEiLCJyb3V0ZUluZm8iLCJzaGFyZWREYXRhIiwiZGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFFQSxJQUFNQSxvQkFBb0IsR0FBRyxjQUE3QjtBQUNBLElBQU1DLDZCQUE2QixHQUFHLFVBQXRDO0FBQ0EsSUFBTUMsOEJBQThCLEdBQUcsVUFBdkM7QUFDQSxJQUFNQyw0QkFBNEIsR0FBRyxTQUFyQzs7QUFFTyxJQUFNQyxhQUFhLEdBQUcsU0FBaEJBLGFBQWdCO0FBQUEsTUFBQ0MsTUFBRCx1RUFBVSxFQUFWO0FBQUEsU0FDM0JBLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlTixvQkFBZixFQUFxQyxJQUFyQyxDQUQyQjtBQUFBLENBQXRCOzs7O0FBR0EsSUFBTU8sa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQjtBQUFBLE1BQUNGLE1BQUQsdUVBQVUsRUFBVjtBQUFBLFNBQ2hDQSxNQUFNLENBQUNDLE9BQVAsQ0FBZUwsNkJBQWYsRUFBOEMsRUFBOUMsQ0FEZ0M7QUFBQSxDQUEzQjs7OztBQUdBLElBQU1PLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0I7QUFBQSxNQUFDSCxNQUFELHVFQUFVLEVBQVY7QUFBQSxTQUNqQ0EsTUFBTSxDQUFDQyxPQUFQLENBQWVKLDhCQUFmLEVBQStDLEVBQS9DLENBRGlDO0FBQUEsQ0FBNUI7Ozs7QUFHQSxJQUFNTyxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLEdBQWlCO0FBQUEsTUFBaEJKLE1BQWdCLHVFQUFQLEVBQU87O0FBQ2hELE1BQUlLLGFBQWEsQ0FBQ0wsTUFBRCxDQUFqQixFQUEyQjtBQUFBLHdCQUNRQSxNQUFNLENBQUNNLEtBQVAsQ0FBYSxLQUFiLENBRFI7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Q0FBdUJILFVBQXZCO0FBQ0Q7QUFDRixHQVJELENBUnNDLENBaUJ0Qzs7O0FBQ0FELEVBQUFBLE9BQU8sQ0FBQ0ksT0FBUixDQUFnQkgsVUFBaEIsRUFsQnNDLENBb0J0Qzs7QUFDQSxTQUFPdEIsS0FBSyxDQUFDa0IsTUFBTixDQUFhUSxPQUFiLENBQVA7QUFDRDs7QUFFTSxTQUFTQyxnQkFBVCxDQUEwQkMsU0FBMUIsRUFBcUM7QUFDMUMsMkJBQ01BLFNBQVMsQ0FBQ0MsVUFBVixHQUF1QkQsU0FBUyxDQUFDQyxVQUFqQyxHQUE4QyxFQURwRCxNQUVLRCxTQUFTLENBQUNFLElBRmY7QUFJRCIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHBvb2xBbGwsIGNyZWF0ZVBvb2wgfSBmcm9tICdzd2ltbWVyJ1xyXG5cclxuY29uc3QgUkVHRVhfVE9fQ1VUX1RPX1JPT1QgPSAvKFxcLi4rPylcXC8uKi9nXHJcbmNvbnN0IFJFR0VYX1RPX1JFTU9WRV9MRUFESU5HX1NMQVNIID0gL15cXC97MSx9L2dcclxuY29uc3QgUkVHRVhfVE9fUkVNT1ZFX1RSQUlMSU5HX1NMQVNIID0gL1xcL3sxLH0kL2dcclxuY29uc3QgUkVHRVhfVE9fUkVNT1ZFX0RPVUJMRV9TTEFTSCA9IC9cXC97Mix9L2dcclxuXHJcbmV4cG9ydCBjb25zdCBjdXRQYXRoVG9Sb290ID0gKHN0cmluZyA9ICcnKSA9PlxyXG4gIHN0cmluZy5yZXBsYWNlKFJFR0VYX1RPX0NVVF9UT19ST09ULCAnJDEnKVxyXG5cclxuZXhwb3J0IGNvbnN0IHRyaW1MZWFkaW5nU2xhc2hlcyA9IChzdHJpbmcgPSAnJykgPT5cclxuICBzdHJpbmcucmVwbGFjZShSRUdFWF9UT19SRU1PVkVfTEVBRElOR19TTEFTSCwgJycpXHJcblxyXG5leHBvcnQgY29uc3QgdHJpbVRyYWlsaW5nU2xhc2hlcyA9IChzdHJpbmcgPSAnJykgPT5cclxuICBzdHJpbmcucmVwbGFjZShSRUdFWF9UT19SRU1PVkVfVFJBSUxJTkdfU0xBU0gsICcnKVxyXG5cclxuZXhwb3J0IGNvbnN0IHRyaW1Eb3VibGVTbGFzaGVzID0gKHN0cmluZyA9ICcnKSA9PiB7XHJcbiAgaWYgKGlzQWJzb2x1dGVVcmwoc3RyaW5nKSkge1xyXG4gICAgY29uc3QgW3NjaGVtZSA9ICcnLCBwYXRoID0gJyddID0gc3RyaW5nLnNwbGl0KCc6Ly8nKVxyXG5cclxuICAgIHJldHVybiBbc2NoZW1lLCBwYXRoLnJlcGxhY2UoUkVHRVhfVE9fUkVNT1ZFX0RPVUJMRV9TTEFTSCwgJy8nKV0uam9pbignOi8vJylcclxuICB9XHJcblxyXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShSRUdFWF9UT19SRU1PVkVfRE9VQkxFX1NMQVNILCAnLycpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhblNsYXNoZXMgPSAoc3RyaW5nLCBvcHRpb25zID0ge30pID0+IHtcclxuICBpZiAoIXN0cmluZykgcmV0dXJuICcnXHJcblxyXG4gIGNvbnN0IHsgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSwgZG91YmxlID0gdHJ1ZSB9ID0gb3B0aW9uc1xyXG4gIGxldCBjbGVhbmVkU3RyaW5nID0gc3RyaW5nXHJcblxyXG4gIGlmIChsZWFkaW5nKSB7XHJcbiAgICBjbGVhbmVkU3RyaW5nID0gdHJpbUxlYWRpbmdTbGFzaGVzKGNsZWFuZWRTdHJpbmcpXHJcbiAgfVxyXG5cclxuICBpZiAodHJhaWxpbmcpIHtcclxuICAgIGNsZWFuZWRTdHJpbmcgPSB0cmltVHJhaWxpbmdTbGFzaGVzKGNsZWFuZWRTdHJpbmcpXHJcbiAgfVxyXG5cclxuICBpZiAoZG91YmxlKSB7XHJcbiAgICBjbGVhbmVkU3RyaW5nID0gdHJpbURvdWJsZVNsYXNoZXMoY2xlYW5lZFN0cmluZylcclxuICB9XHJcblxyXG4gIHJldHVybiBjbGVhbmVkU3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXRoSm9pbiguLi5wYXRocykge1xyXG4gIGxldCBuZXdQYXRoID0gcGF0aHMubWFwKGNsZWFuU2xhc2hlcykuam9pbignLycpXHJcbiAgaWYgKCFuZXdQYXRoIHx8IG5ld1BhdGggPT09ICcvJykge1xyXG4gICAgcmV0dXJuICcvJ1xyXG4gIH1cclxuXHJcbiAgbmV3UGF0aCA9IGNsZWFuU2xhc2hlcyhuZXdQYXRoKVxyXG4gIGlmIChuZXdQYXRoLmluY2x1ZGVzKCc/JykpIHtcclxuICAgIG5ld1BhdGggPSBuZXdQYXRoLnN1YnN0cmluZygwLCBuZXdQYXRoLmluZGV4T2YoJz8nKSlcclxuICB9XHJcbiAgcmV0dXJuIG5ld1BhdGhcclxufVxyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiBpcyBmb3IgZXh0cmFjdGluZyBhIHJvdXRlUGF0aCBmcm9tIGEgcGF0aCBvciBzdHJpbmdcclxuLy8gUm91dGVQYXRocyBkbyBub3QgaGF2ZSBxdWVyeSBwYXJhbXMsIGJhc2VQYXRocywgYW5kIHNob3VsZFxyXG4vLyByZXNlbWJsZSB0aGUgc2FtZSBzdHJpbmcgYXMgcGFzc2VkIGluIHRoZSBzdGF0aWMuY29uZmlnLmpzIHJvdXRlc1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVQYXRoKHJvdXRlUGF0aCkge1xyXG4gIC8vIERldGVjdCBmYWxzZXkgcGF0aHMgYW5kIHRoZSByb290IHBhdGhcclxuICBpZiAoXHJcbiAgICAhcm91dGVQYXRoIHx8XHJcbiAgICByb3V0ZVBhdGggPT09ICcvJyB8fFxyXG4gICAgcm91dGVQYXRoID09PSBwcm9jZXNzLmVudi5SRUFDVF9TVEFUSUNfQkFTRV9QQVRIXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gJy8nXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgb3JpZ2luLCBoYXNoZXMsIGFuZCBxdWVyeSBwYXJhbXNcclxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcm91dGVQYXRoID0gcm91dGVQYXRoLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLm9yaWdpbiwgJycpXHJcbiAgICByb3V0ZVBhdGggPSByb3V0ZVBhdGgucmVwbGFjZSgvIy4qLywgJycpXHJcbiAgICByb3V0ZVBhdGggPSByb3V0ZVBhdGgucmVwbGFjZSgvXFw/LiovLCAnJylcclxuICB9XHJcblxyXG4gIC8vIEJlIHN1cmUgdG8gcmVtb3ZlIHRoZSBiYXNlIHBhdGhcclxuICBpZiAocHJvY2Vzcy5lbnYuUkVBQ1RfU1RBVElDX0JBU0VfUEFUSCkge1xyXG4gICAgcm91dGVQYXRoID0gcm91dGVQYXRoLnJlcGxhY2UoXHJcbiAgICAgIG5ldyBSZWdFeHAoYF5cXFxcLz8ke3Byb2Nlc3MuZW52LlJFQUNUX1NUQVRJQ19CQVNFX1BBVEh9XFxcXC9gKSxcclxuICAgICAgJydcclxuICAgIClcclxuICB9XHJcbiAgcm91dGVQYXRoID0gcm91dGVQYXRoIHx8ICcvJ1xyXG4gIHJldHVybiBwYXRoSm9pbihyb3V0ZVBhdGgpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBBcnJheShhcmcsIGRlZmF1bHRWYWx1ZSkge1xyXG4gIGFyZyA9IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZ1swXSA6IGFyZ1xyXG4gIGlmICghYXJnICYmIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxyXG4gIH1cclxuICByZXR1cm4gYXJnXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChhKSB7XHJcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KGEpICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGUoZnJvbSwgdG8pIHtcclxuICBjb25zb2xlLndhcm4oXHJcbiAgICBgUmVhY3QtU3RhdGljIGRlcHJlY2F0aW9uIG5vdGljZTogJHtmcm9tfSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgJHt0b30gaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5gXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZhbChmcm9tKSB7XHJcbiAgY29uc29sZS53YXJuKFxyXG4gICAgYFJlYWN0LVN0YXRpYyByZW1vdmFsIG5vdGljZTogJHtmcm9tfSBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBSZWFjdC1TdGF0aWMuIFBsZWFzZSByZWZlciB0byB0aGUgQ0hBTkdFTE9HIGZvciBkZXRhaWxzLmBcclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xyXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gL15bYS16XVthLXowLTkrLi1dKjovLnRlc3QodXJsKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhdGhBYnNvbHV0ZShwYXRoKSB7XHJcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuICcvJ1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzQWJzb2x1dGVVcmwocGF0aCkpIHtcclxuICAgIHJldHVybiBwYXRoXHJcbiAgfVxyXG5cclxuICByZXR1cm4gYC8ke3RyaW1MZWFkaW5nU2xhc2hlcyhwYXRoKX1gXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VIb29rcyhob29rcywgeyBzeW5jIH0gPSB7fSkge1xyXG4gIC8vIFRoZXNlIHJldHVybnMgYSBydW5uZXIgdGhhdCB0YWtlcyBhIHZhbHVlIChhbmQgb3B0aW9ucykgYW5kXHJcbiAgLy8gcmVkdWNlcyB0aGUgdmFsdWUgdGhyb3VnaCBlYWNoIGhvb2ssIHJldHVybmluZyB0aGVcclxuICAvLyBmaW5hbCB2YWx1ZVxyXG4gIC8vIGNvbXBhcmUgaXMgYSBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIGNvbXBhcmVcclxuICAvLyB0aGUgcHJldiBhbmQgbmV4dCB2YWx1ZSBhbmQgZGVjaWRlIHdoaWNoIHRvIHVzZS5cclxuICAvLyBCeSBkZWZhdWx0LCBpZiB1bmRlZmluZWQgaXMgcmV0dXJuZWQgZnJvbSBhIHJlZHVjZXIsIHRoZSBwcmV2IHZhbHVlXHJcbiAgLy8gaXMgcmV0YWluZWRcclxuXHJcbiAgLy8gSWYgc3luY2hyb25vdXMsIHRoaW5ncyBhcmUgc2ltcGxlXHJcbiAgaWYgKHN5bmMpIHtcclxuICAgIHJldHVybiAodmFsdWUsIG9wdGlvbnMpID0+XHJcbiAgICAgIGhvb2tzLnJlZHVjZSgocHJldiwgaG9vaykgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBob29rKHByZXYsIG9wdGlvbnMpXHJcbiAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdFeHBlY3RlZCBob29rIHRvIHJldHVybiBhIHZhbHVlLCBidXQgcmVjZWl2ZWQgcHJvbWlzZSBpbnN0ZWFkLiBBIHBsdWdpbiBpcyBhdHRlbXB0aW5nIHRvIHVzZSBhIHN5bmMgcGx1Z2luIHdpdGggYW4gYXN5bmMgZnVuY3Rpb24hJ1xyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZW9mIG5leHQgIT09ICd1bmRlZmluZWQnID8gbmV4dCA6IHByZXZcclxuICAgICAgfSwgdmFsdWUpXHJcbiAgfVxyXG5cclxuICAvLyBXZSBjcmVhdGUgYSBtYXAgb2YgaG9vayBoYW5kbGVycyB0aGF0IHBvaW50IHRvIHRoZSBuZXh0IGhvb2tcclxuICAvLyBpbiBsaW5lIGFuZCByZWR1Y2UgdGhlIHZhbHVlIHRocm91Z2hvdXQgKG9yIHJldHVybiBpdCBpZiBpdCdzIGRvbmUpXHJcbiAgcmV0dXJuIChzdGFydFZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICBjb25zdCBob29rTGlzdCA9IGhvb2tzLm1hcCgoaG9vaywgaW5kZXgpID0+IGFzeW5jIGxhc3RWYWx1ZSA9PiB7XHJcbiAgICAgIGxldCBuZXh0VmFsdWUgPSBhd2FpdCBob29rKGxhc3RWYWx1ZSwgb3B0aW9ucylcclxuICAgICAgbmV4dFZhbHVlID0gdHlwZW9mIG5leHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBuZXh0VmFsdWUgOiBsYXN0VmFsdWVcclxuICAgICAgaWYgKGhvb2tMaXN0W2luZGV4ICsgMV0pIHtcclxuICAgICAgICByZXR1cm4gaG9va0xpc3RbaW5kZXggKyAxXShuZXh0VmFsdWUpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5leHRWYWx1ZVxyXG4gICAgfSlcclxuICAgIHJldHVybiBob29rTGlzdC5sZW5ndGggPyBob29rTGlzdFswXShzdGFydFZhbHVlKSA6IHN0YXJ0VmFsdWVcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBIb29rcyhob29rcywgeyBzeW5jIH0gPSB7fSkge1xyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHN0YXRlIGFuZCByZXR1cm5zXHJcbiAgLy8gYSBmbGF0IGFycmF5IG9mIHZhbHVlcyBtYXBwZWQgZnJvbSBlYWNoIGhvb2tcclxuICBpZiAoc3luYykge1xyXG4gICAgcmV0dXJuIHN0YXRlID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0cyA9IGhvb2tzLm1hcChob29rID0+IGhvb2soc3RhdGUpKVxyXG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdXHJcbiAgICBjb25zdCBob29rTGlzdCA9IGhvb2tzLm1hcCgoaG9vaywgaW5kZXgpID0+IGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0c1tpbmRleF0gPSBhd2FpdCBob29rKHN0YXRlKVxyXG5cclxuICAgICAgaWYgKGhvb2tMaXN0W2luZGV4ICsgMV0pIHtcclxuICAgICAgICByZXR1cm4gaG9va0xpc3RbaW5kZXggKyAxXSgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcihkID0+IHR5cGVvZiBkICE9PSAndW5kZWZpbmVkJylcclxuICAgIH0pXHJcbiAgICByZXR1cm4gaG9va0xpc3QubGVuZ3RoID8gaG9va0xpc3RbMF0oKSA6IFtdXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9va3MocGx1Z2lucywgaG9vaykge1xyXG4gIGlmICghaG9vaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGhvb2sgSUQgaXMgcmVxdWlyZWQhJylcclxuICB9XHJcbiAgLy8gVGhlIGZsYXQgaG9va3NcclxuICBjb25zdCBob29rcyA9IFtdXHJcblxyXG4gIC8vIEFkZHMgYSBwbHVnaW4gaG9vayB0byB0aGUgaG9vayBsaXN0XHJcbiAgY29uc3QgYWRkVG9Ib29rcyA9IHBsdWdpbiA9PiB7XHJcbiAgICAvLyBBZGQgdGhlIGhvb2tcclxuICAgIGhvb2tzLnB1c2gocGx1Z2luLmhvb2tzW2hvb2tdKVxyXG5cclxuICAgIC8vIFJlY3Vyc2UgaW50byBzdWIgcGx1Z2lucyBpZiBuZWVkcyBiZVxyXG4gICAgaWYgKHBsdWdpbi5wbHVnaW5zKSB7XHJcbiAgICAgIHBsdWdpbi5wbHVnaW5zLmZvckVhY2goYWRkVG9Ib29rcylcclxuICAgIH1cclxuICB9XHJcbiAgLy8gU3RhcnQgd2l0aCB0aGUgY29uZmlnIHBsdWdpbnNcclxuICBwbHVnaW5zLmZvckVhY2goYWRkVG9Ib29rcylcclxuXHJcbiAgLy8gRmlsdGVyIG91dCBmYWxzZXkgZW50cmllc1xyXG4gIHJldHVybiBob29rcy5maWx0ZXIoQm9vbGVhbilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxSb3V0ZURhdGEocm91dGVJbmZvKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLihyb3V0ZUluZm8uc2hhcmVkRGF0YSA/IHJvdXRlSW5mby5zaGFyZWREYXRhIDoge30pLFxyXG4gICAgLi4ucm91dGVJbmZvLmRhdGEsXHJcbiAgfVxyXG59XHJcbiJdfQ==