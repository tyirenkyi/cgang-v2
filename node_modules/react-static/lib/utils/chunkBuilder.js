"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.absoluteToRelativeChunkName = exports.chunkNameFromFile = void 0;

var _path = _interopRequireDefault(require("path"));

var _ = require(".");

// Instead of using path.sep, we always want to test for all of them. This makes
// the tests consistent and means we can write tests with either separator
var escapedPathSeps = (0, _.escapeRegExp)("".concat(_path["default"].win32.sep).concat(_path["default"].posix.sep));

var chunkNameFromFile = function chunkNameFromFile(filename) {
  // Normalize filename for path.join
  filename = filename.replace(new RegExp("[".concat(escapedPathSeps, "]"), 'g'), _path["default"].sep); // Remove the extension

  return _path["default"].join(_path["default"].dirname(filename), _path["default"].basename(filename, _path["default"].extname(filename))) // Remove the drive letter or leading (back)slash
  .replace(/^(?:[A-Z]:)?(?:\\|\/)/, '') // Now turn it into a name
  .replace(new RegExp("[".concat(escapedPathSeps, "]"), 'g'), '-');
};

exports.chunkNameFromFile = chunkNameFromFile;

var absoluteToRelativeChunkName = function absoluteToRelativeChunkName(ROOT, chunkName) {
  var pathPrefix = chunkNameFromFile(ROOT); // inner components can simply be added aswell

  if (!chunkName.startsWith(pathPrefix)) {
    return chunkName;
  } // The templates starts with the absolute path, that's the one we want to
  // replace. It's length + 1 because otherwise it would start with a hyphen


  return chunkNameFromFile(chunkName).substring(pathPrefix.length + 1);
};

exports.absoluteToRelativeChunkName = absoluteToRelativeChunkName;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jaHVua0J1aWxkZXIuanMiXSwibmFtZXMiOlsiZXNjYXBlZFBhdGhTZXBzIiwicGF0aCIsIndpbjMyIiwic2VwIiwicG9zaXgiLCJjaHVua05hbWVGcm9tRmlsZSIsImZpbGVuYW1lIiwicmVwbGFjZSIsIlJlZ0V4cCIsImpvaW4iLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiYWJzb2x1dGVUb1JlbGF0aXZlQ2h1bmtOYW1lIiwiUk9PVCIsImNodW5rTmFtZSIsInBhdGhQcmVmaXgiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBTUEsZUFBZSxHQUFHLDhCQUFnQkMsaUJBQUtDLEtBQUwsQ0FBV0MsR0FBM0IsU0FBaUNGLGlCQUFLRyxLQUFMLENBQVdELEdBQTVDLEVBQXhCOztBQUVPLElBQU1FLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsQ0FBQUMsUUFBUSxFQUFJO0FBQzNDO0FBQ0FBLEVBQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDQyxPQUFULENBQWlCLElBQUlDLE1BQUosWUFBZVIsZUFBZixRQUFtQyxHQUFuQyxDQUFqQixFQUEwREMsaUJBQUtFLEdBQS9ELENBQVgsQ0FGMkMsQ0FHM0M7O0FBQ0EsU0FDRUYsaUJBQ0dRLElBREgsQ0FFSVIsaUJBQUtTLE9BQUwsQ0FBYUosUUFBYixDQUZKLEVBR0lMLGlCQUFLVSxRQUFMLENBQWNMLFFBQWQsRUFBd0JMLGlCQUFLVyxPQUFMLENBQWFOLFFBQWIsQ0FBeEIsQ0FISixFQUtFO0FBTEYsR0FNR0MsT0FOSCxDQU1XLHVCQU5YLEVBTW9DLEVBTnBDLEVBT0U7QUFQRixHQVFHQSxPQVJILENBUVcsSUFBSUMsTUFBSixZQUFlUixlQUFmLFFBQW1DLEdBQW5DLENBUlgsRUFRb0QsR0FScEQsQ0FERjtBQVdELENBZk07Ozs7QUFpQkEsSUFBTWEsMkJBQTJCLEdBQUcsU0FBOUJBLDJCQUE4QixDQUFDQyxJQUFELEVBQU9DLFNBQVAsRUFBcUI7QUFDOUQsTUFBTUMsVUFBVSxHQUFHWCxpQkFBaUIsQ0FBQ1MsSUFBRCxDQUFwQyxDQUQ4RCxDQUc5RDs7QUFDQSxNQUFJLENBQUNDLFNBQVMsQ0FBQ0UsVUFBVixDQUFxQkQsVUFBckIsQ0FBTCxFQUF1QztBQUNyQyxXQUFPRCxTQUFQO0FBQ0QsR0FONkQsQ0FROUQ7QUFDQTs7O0FBQ0EsU0FBT1YsaUJBQWlCLENBQUNVLFNBQUQsQ0FBakIsQ0FBNkJHLFNBQTdCLENBQXVDRixVQUFVLENBQUNHLE1BQVgsR0FBb0IsQ0FBM0QsQ0FBUDtBQUNELENBWE0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xyXG5cclxuaW1wb3J0IHsgZXNjYXBlUmVnRXhwIH0gZnJvbSAnLidcclxuXHJcbi8vIEluc3RlYWQgb2YgdXNpbmcgcGF0aC5zZXAsIHdlIGFsd2F5cyB3YW50IHRvIHRlc3QgZm9yIGFsbCBvZiB0aGVtLiBUaGlzIG1ha2VzXHJcbi8vIHRoZSB0ZXN0cyBjb25zaXN0ZW50IGFuZCBtZWFucyB3ZSBjYW4gd3JpdGUgdGVzdHMgd2l0aCBlaXRoZXIgc2VwYXJhdG9yXHJcbmNvbnN0IGVzY2FwZWRQYXRoU2VwcyA9IGVzY2FwZVJlZ0V4cChgJHtwYXRoLndpbjMyLnNlcH0ke3BhdGgucG9zaXguc2VwfWApXHJcblxyXG5leHBvcnQgY29uc3QgY2h1bmtOYW1lRnJvbUZpbGUgPSBmaWxlbmFtZSA9PiB7XHJcbiAgLy8gTm9ybWFsaXplIGZpbGVuYW1lIGZvciBwYXRoLmpvaW5cclxuICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7ZXNjYXBlZFBhdGhTZXBzfV1gLCAnZycpLCBwYXRoLnNlcClcclxuICAvLyBSZW1vdmUgdGhlIGV4dGVuc2lvblxyXG4gIHJldHVybiAoXHJcbiAgICBwYXRoXHJcbiAgICAgIC5qb2luKFxyXG4gICAgICAgIHBhdGguZGlybmFtZShmaWxlbmFtZSksXHJcbiAgICAgICAgcGF0aC5iYXNlbmFtZShmaWxlbmFtZSwgcGF0aC5leHRuYW1lKGZpbGVuYW1lKSlcclxuICAgICAgKVxyXG4gICAgICAvLyBSZW1vdmUgdGhlIGRyaXZlIGxldHRlciBvciBsZWFkaW5nIChiYWNrKXNsYXNoXHJcbiAgICAgIC5yZXBsYWNlKC9eKD86W0EtWl06KT8oPzpcXFxcfFxcLykvLCAnJylcclxuICAgICAgLy8gTm93IHR1cm4gaXQgaW50byBhIG5hbWVcclxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7ZXNjYXBlZFBhdGhTZXBzfV1gLCAnZycpLCAnLScpXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYWJzb2x1dGVUb1JlbGF0aXZlQ2h1bmtOYW1lID0gKFJPT1QsIGNodW5rTmFtZSkgPT4ge1xyXG4gIGNvbnN0IHBhdGhQcmVmaXggPSBjaHVua05hbWVGcm9tRmlsZShST09UKVxyXG5cclxuICAvLyBpbm5lciBjb21wb25lbnRzIGNhbiBzaW1wbHkgYmUgYWRkZWQgYXN3ZWxsXHJcbiAgaWYgKCFjaHVua05hbWUuc3RhcnRzV2l0aChwYXRoUHJlZml4KSkge1xyXG4gICAgcmV0dXJuIGNodW5rTmFtZVxyXG4gIH1cclxuXHJcbiAgLy8gVGhlIHRlbXBsYXRlcyBzdGFydHMgd2l0aCB0aGUgYWJzb2x1dGUgcGF0aCwgdGhhdCdzIHRoZSBvbmUgd2Ugd2FudCB0b1xyXG4gIC8vIHJlcGxhY2UuIEl0J3MgbGVuZ3RoICsgMSBiZWNhdXNlIG90aGVyd2lzZSBpdCB3b3VsZCBzdGFydCB3aXRoIGEgaHlwaGVuXHJcbiAgcmV0dXJuIGNodW5rTmFtZUZyb21GaWxlKGNodW5rTmFtZSkuc3Vic3RyaW5nKHBhdGhQcmVmaXgubGVuZ3RoICsgMSlcclxufVxyXG4iXX0=